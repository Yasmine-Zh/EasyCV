"""
Website generator for resume profiles (HTML and GitHub Pages).
"""

import logging
from pathlib import Path
from typing import Dict, Any, Optional
import re
from datetime import datetime

try:
    from markdown2 import markdown
except ImportError:
    markdown = None

class WebsiteGenerator:
    """Generator for HTML website format resume profiles."""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
        if markdown is None:
            self.logger.warning("markdown2 not available. Limited HTML generation.")
    
    def generate(self, profile_data: Dict[str, Any], output_dir: Path, 
                profile_name: str, version: str, style_analysis: Optional[Dict[str, Any]] = None) -> Path:
        """
        Generate HTML website resume.
        
        Args:
            profile_data: Profile content and metadata
            output_dir: Directory for output files
            profile_name: Name of the profile
            version: Version string
            style_analysis: Style analysis for theming
            
        Returns:
            Path to generated HTML file
        """
        try:
            # Generate filename
            filename = f"{profile_name}.{version}.html"
            output_path = output_dir / filename
            
            # Get content from profile data
            markdown_content = profile_data.get('content', '')
            
            # Generate HTML
            html_content = self._generate_html(
                markdown_content, profile_name, version, style_analysis
            )
            
            # Write HTML file
            with open(output_path, 'w', encoding='utf-8') as file:
                file.write(html_content)
            
            # Generate supporting files
            self._generate_css_file(output_dir, style_analysis)
            self._generate_github_pages_config(output_dir, profile_name)
            
            self.logger.info(f"Generated HTML website: {output_path}")
            return output_path
            
        except Exception as e:
            self.logger.error(f"Error generating website: {str(e)}")
            raise Exception(f"Failed to generate website: {str(e)}")
    
    def _generate_html(self, markdown_content: str, profile_name: str, 
                      version: str, style_analysis: Optional[Dict[str, Any]] = None) -> str:
        """Generate complete HTML document."""
        # Remove YAML front matter
        clean_content = self._remove_yaml_frontmatter(markdown_content)
        
        # Convert markdown to HTML
        if markdown is not None:
            body_html = markdown(clean_content, extras=['fenced-code-blocks', 'tables'])
        else:
            body_html = self._simple_markdown_to_html(clean_content)
        
        # Apply custom processing
        body_html = self._enhance_html_content(body_html)
        
        # Generate complete HTML document
        html_template = self._get_html_template(profile_name, version, style_analysis)
        
        return html_template.replace('{{CONTENT}}', body_html)
    
    def _get_html_template(self, profile_name: str, version: str, 
                          style_analysis: Optional[Dict[str, Any]] = None) -> str:
        """Get HTML template for the resume."""
        theme_class = self._determine_theme_class(style_analysis)
        
        return f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{profile_name} - Resume</title>
    <meta name="description" content="Professional resume of {profile_name}">
    <meta name="author" content="{profile_name}">
    <link rel="stylesheet" href="styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="{theme_class}">
    <div class="container">
        <header class="header">
            <div class="header-content">
                <h1 class="name">{profile_name}</h1>
                <p class="version">Version {version}</p>
            </div>
        </header>
        
        <main class="main-content">
            {{CONTENT}}
        </main>
        
        <footer class="footer">
            <p>Generated by <a href="https://github.com/your-repo/EasyCV" target="_blank">EasyCV</a> - {datetime.now().strftime('%Y')}</p>
        </footer>
    </div>
    
    <script src="script.js"></script>
</body>
</html>"""
    
    def _determine_theme_class(self, style_analysis: Optional[Dict[str, Any]] = None) -> str:
        """Determine theme class based on style analysis."""
        if not style_analysis:
            return "theme-professional"
            
        # Analyze style preferences and return appropriate theme
        analysis_text = style_analysis.get('analysis', '').lower()
        
        if 'modern' in analysis_text or 'minimal' in analysis_text:
            return "theme-modern"
        elif 'creative' in analysis_text or 'colorful' in analysis_text:
            return "theme-creative"
        elif 'traditional' in analysis_text or 'classic' in analysis_text:
            return "theme-traditional"
        else:
            return "theme-professional"
    
    def _enhance_html_content(self, html_content: str) -> str:
        """Enhance HTML content with additional styling and structure."""
        # Add classes to common elements
        html_content = re.sub(r'<h1>', '<h1 class="section-title">', html_content)
        html_content = re.sub(r'<h2>', '<h2 class="subsection-title">', html_content)
        html_content = re.sub(r'<h3>', '<h3 class="item-title">', html_content)
        
        # Enhance lists
        html_content = re.sub(r'<ul>', '<ul class="skill-list">', html_content)
        html_content = re.sub(r'<ol>', '<ol class="experience-list">', html_content)
        
        # Add contact information styling
        html_content = self._style_contact_info(html_content)
        
        return html_content
    
    def _style_contact_info(self, html_content: str) -> str:
        """Add special styling for contact information."""
        # Look for common contact patterns and wrap them
        email_pattern = r'([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})'
        html_content = re.sub(email_pattern, r'<a href="mailto:\1" class="contact-email">\1</a>', html_content)
        
        # Phone pattern (simple)
        phone_pattern = r'(\+?[\d\s\-\(\)]{10,})'
        html_content = re.sub(phone_pattern, r'<span class="contact-phone">\1</span>', html_content)
        
        return html_content
    
    def _generate_css_file(self, output_dir: Path, style_analysis: Optional[Dict[str, Any]] = None):
        """Generate CSS file for the website."""
        css_content = self._get_css_content(style_analysis)
        
        css_path = output_dir / "styles.css"
        with open(css_path, 'w', encoding='utf-8') as file:
            file.write(css_content)
            
        self.logger.info(f"Generated CSS file: {css_path}")
    
    def _get_css_content(self, style_analysis: Optional[Dict[str, Any]] = None) -> str:
        """Get CSS content for the website."""
        return """/* EasyCV Resume Styles */

/* Reset and base styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    line-height: 1.6;
    color: #333;
    background-color: #f8f9fa;
}

.container {
    max-width: 900px;
    margin: 0 auto;
    background: white;
    box-shadow: 0 0 20px rgba(0,0,0,0.1);
    min-height: 100vh;
}

/* Header */
.header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 2rem;
    text-align: center;
}

.name {
    font-size: 2.5rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
}

.version {
    opacity: 0.8;
    font-size: 0.9rem;
}

/* Main content */
.main-content {
    padding: 2rem;
}

.section-title {
    color: #2c3e50;
    border-bottom: 3px solid #667eea;
    padding-bottom: 0.5rem;
    margin: 2rem 0 1rem 0;
    font-size: 1.8rem;
    font-weight: 600;
}

.subsection-title {
    color: #34495e;
    margin: 1.5rem 0 0.8rem 0;
    font-size: 1.3rem;
    font-weight: 500;
}

.item-title {
    color: #4a5568;
    margin: 1rem 0 0.5rem 0;
    font-size: 1.1rem;
    font-weight: 500;
}

/* Lists */
.skill-list, .experience-list {
    margin: 1rem 0;
    padding-left: 1.5rem;
}

.skill-list li, .experience-list li {
    margin-bottom: 0.5rem;
}

/* Contact information */
.contact-email {
    color: #667eea;
    text-decoration: none;
}

.contact-email:hover {
    text-decoration: underline;
}

.contact-phone {
    color: #4a5568;
    font-weight: 500;
}

/* Paragraphs */
p {
    margin-bottom: 1rem;
    text-align: justify;
}

/* Footer */
.footer {
    background: #f8f9fa;
    padding: 1rem;
    text-align: center;
    color: #6c757d;
    border-top: 1px solid #dee2e6;
}

.footer a {
    color: #667eea;
    text-decoration: none;
}

.footer a:hover {
    text-decoration: underline;
}

/* Theme variations */
.theme-modern .header {
    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
}

.theme-creative .header {
    background: linear-gradient(135deg, #ff6b6b 0%, #feca57 100%);
}

.theme-traditional .header {
    background: #2c3e50;
}

/* Responsive design */
@media (max-width: 768px) {
    .container {
        margin: 0;
        box-shadow: none;
    }
    
    .header, .main-content {
        padding: 1rem;
    }
    
    .name {
        font-size: 2rem;
    }
    
    .section-title {
        font-size: 1.5rem;
    }
}

/* Print styles */
@media print {
    body {
        background: white;
    }
    
    .container {
        box-shadow: none;
    }
    
    .header {
        background: #2c3e50 !important;
        -webkit-print-color-adjust: exact;
        color-adjust: exact;
    }
    
    .footer {
        display: none;
    }
}"""
    
    def _generate_github_pages_config(self, output_dir: Path, profile_name: str):
        """Generate configuration files for GitHub Pages."""
        # Generate _config.yml for Jekyll
        config_content = f"""title: {profile_name} Resume
description: Professional resume generated by EasyCV
theme: minima
markdown: kramdown
highlighter: rouge

# SEO settings
author: {profile_name}
url: ""
baseurl: ""

# Exclude files
exclude:
  - metadata.json
  - "*.md"
  - README.md

# Include files
include:
  - "*.html"
  - "*.css"
  - "*.js"
"""
        
        config_path = output_dir / "_config.yml"
        with open(config_path, 'w', encoding='utf-8') as file:
            file.write(config_content)
            
        # Generate index.html redirect (if main HTML file has different name)
        index_content = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="refresh" content="0; url=./{profile_name}.html">
    <title>Redirecting...</title>
</head>
<body>
    <p>If you are not redirected automatically, <a href="./{profile_name}.html">click here</a>.</p>
</body>
</html>"""
        
        index_path = output_dir / "index.html"
        with open(index_path, 'w', encoding='utf-8') as file:
            file.write(index_content)
            
        self.logger.info("Generated GitHub Pages configuration files")
    
    def _simple_markdown_to_html(self, markdown_content: str) -> str:
        """Simple markdown to HTML conversion (fallback)."""
        html = markdown_content
        
        # Convert headings
        html = re.sub(r'^# (.+)$', r'<h1>\1</h1>', html, flags=re.MULTILINE)
        html = re.sub(r'^## (.+)$', r'<h2>\1</h2>', html, flags=re.MULTILINE)
        html = re.sub(r'^### (.+)$', r'<h3>\1</h3>', html, flags=re.MULTILINE)
        
        # Convert lists
        html = re.sub(r'^- (.+)$', r'<li>\1</li>', html, flags=re.MULTILINE)
        html = re.sub(r'(<li>.*</li>)', r'<ul>\1</ul>', html, flags=re.DOTALL)
        
        # Convert paragraphs
        paragraphs = html.split('\n\n')
        html_paragraphs = []
        
        for para in paragraphs:
            para = para.strip()
            if para and not para.startswith('<'):
                html_paragraphs.append(f'<p>{para}</p>')
            else:
                html_paragraphs.append(para)
                
        return '\n\n'.join(html_paragraphs)
    
    def _remove_yaml_frontmatter(self, content: str) -> str:
        """Remove YAML front matter from content."""
        if not content.startswith('---'):
            return content
            
        lines = content.split('\n')
        yaml_end = -1
        
        for i, line in enumerate(lines[1:], 1):
            if line.strip() == '---':
                yaml_end = i
                break
        
        if yaml_end > 0:
            return '\n'.join(lines[yaml_end + 1:]).lstrip('\n')
        else:
            return content 